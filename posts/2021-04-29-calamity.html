<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Write your own Discord bot in Haskell with calamity - MorrowM</title>
    <link rel="stylesheet" href="../css/default.css" />
    <link rel="stylesheet" href="../css/highlightjs/atom-one-dark.min.css">
    <script src="../js/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <link rel="icon" href="../favicon.svg">
</head>

<body>
    <div class="not-footer">
        <header>
            <div class="logo">
                <a class="no-hover" href="../">MorrowM</a>
            </div>
            <nav>
                <a class="highlight-hover" href="../">Home</a>
                <a class="highlight-hover" href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1 class="title">Write your own Discord bot in Haskell with calamity</h1>
            <article>
    <section class="header">
        April 29, 2021
        
    </section>
    <section>
        <p><a href="https://hackage.haskell.org/package/calamity"><code>calamity</code></a> is the most fully-featured library for writing Discord bots on Hackage, rivaling frameworks like <code>discord.py</code> and <code>discord.js</code> in features, while offering all the benefits of Haskell: a strong type system, pure functions, and risk-free refactoring. It may however seem impenetrable at first glance, using many language extensions such as <code>TypeApplications</code>, <code>TypeFamilies</code>, and <code>DataKinds</code>. It also uses the <a href="https://hackage.haskell.org/package/polysemy"><code>polysemy</code></a> effect system rather than the more common <a href="https://hackage.haskell.org/package/mtl"><code>mtl</code></a>. The end result, however, is a very nice interface for making bots.</p>
<p>This post is intended to guide those less familiar with this part of the Haskell ecosystem on how to write their own bots using <code>calamity</code> and hopefully come out of the experience with a greater understanding of how to use these features and how they can be leveraged in their own programs and libraries. It‚Äôs possible to use <code>calamity</code> without understanding all the types involved, but it becomes significantly harder to debug and to understand any error messages you may get.</p>
<p>I recommend following along with the <a href="https://hackage.haskell.org/package/calamity">Hackage documentation</a> open. You can search the haddocks by pressing <code>s</code> to open a search dialogue.</p>
<h2 id="libraries">Libraries</h2>
<h3 id="polysemy"><code>polysemy</code></h3>
<p>When writing real-world IO-heavy applications, it‚Äôs almost always advantageous to use an effect system for storing configuration data, error handling, incorporating state, etc. A common choice is <code>mtl</code>, the monad transformer library. <code>polysemy</code> is another such effect system that opts for working in a single monad, the <code>Sem r</code> monad, which is parameterized by a type-level list of effects, called the ‚Äúeffect row‚Äù.</p>
<p>Here‚Äôs an example snippet of code using <code>mtl</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Config</span> <span class="ot">=</span> <span class="dt">Config</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> cmdPrefix ::</span> <span class="dt">Text</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  , <span class="op">...</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>handleMessage </span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> (<span class="dt">MonadReader</span> <span class="dt">Config</span> m, <span class="dt">MonadIO</span> m)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> <span class="dt">String</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> m ()</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>handleMessage msg <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  prefix <span class="ot">&lt;-</span> asks cmdPrefix</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  when (prefix <span class="ot">`isPrefixOf`</span> msg) <span class="op">$</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    liftIO <span class="op">$</span> <span class="fu">putStrLn</span> <span class="st">&quot;Received a command: &quot;</span> <span class="op">&lt;&gt;</span> msg</span></code></pre></div>
<p>Using <code>polysemy</code> we‚Äôd instead work in the <code>Sem r</code> monad and require that the effect row contain the effects we need using <code>Member</code>, which takes an effect and an effect row and yields a constraint that the effect must be present in the effect row.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>handleMessage </span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> (<span class="dt">Member</span> (<span class="dt">Reader</span> <span class="dt">Config</span>) r, <span class="dt">Member</span> (<span class="dt">Embed</span> <span class="dt">IO</span>) r)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> <span class="dt">String</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">Sem</span> r ()</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>handleMessage msg <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  prefix <span class="ot">&lt;-</span> asks <span class="op">@</span><span class="dt">Config</span> cmdPrefix</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  when (prefix <span class="ot">`isPrefixOf`</span> msg) <span class="op">$</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    embed <span class="op">.</span> <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;Received a command: &quot;</span> <span class="op">&lt;&gt;</span> msg</span></code></pre></div>
<p>As you can see, all we have to do is declare which effects we require to be present in the effect row. <code>polysemy</code> also encourages using more granular effects instead of using <code>IO</code>, so we could have used the <a href="https://hackage.haskell.org/package/polysemy-1.5.0.0/docs/Polysemy-Trace.html#t:Trace"><code>Trace</code></a> effect instead and called <a href="https://hackage.haskell.org/package/polysemy-1.5.0.0/docs/Polysemy-Trace.html#v:trace"><code>trace</code></a> function, which means all we require is that our effect row can log strings, whatever that may mean. This removes our dependency on the <code>IO</code> monad and makes our code more flexible.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>handleMessage </span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> (<span class="dt">Member</span> (<span class="dt">Reader</span> <span class="dt">Config</span>) r, <span class="dt">Member</span> <span class="dt">Trace</span> r)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> <span class="dt">String</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">Sem</span> r ()</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>handleMessage msg <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  prefix <span class="ot">&lt;-</span> asks <span class="op">@</span><span class="dt">Config</span> cmdPrefix</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  when (prefix <span class="ot">`isPrefixOf`</span> msg) <span class="op">$</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    trace <span class="op">$</span> <span class="st">&quot;Received a command: &quot;</span> <span class="op">&lt;&gt;</span> msg</span></code></pre></div>
<p>How these effects are interpreted, and which concrete effect row is inferred depends on which <em>effect interpreters</em> we choose. For the <code>Reader</code> effect there‚Äôs really only one interpreter that <code>polysemy</code> provides to us, <code>runReader :: i -&gt; Sem (Reader i ': r) a -&gt; Sem r a</code>. The type signature says that given some value <code>i</code> we can handle a <code>Reader i</code> effect from the effect row. Remember that the effect row is just a type-level list of effects, so <code>(Reader i ': r)</code> just pattern matches on that list, a list with <code>Reader i</code> as its head and <code>r</code> as its tail. So the interpreter essentially strips an effect off the head of the effect row.</p>
<p>For interpreting the <code>Trace</code> effect we have a few options. We could gather all the logged messages into a list with <code>runTraceList :: Sem (Trace ': r) a -&gt; Sem r ([String], a)</code>, we could also just ignore the messages with <code>ignoreTrace :: Sem (Trace ': r) a -&gt; Sem r a</code>. But in this case we‚Äôll have the messages printed to <code>stdout</code> with <code>traceToIO :: Member (Embed IO) r =&gt; Sem (Trace ': r) a -&gt; Sem r a</code>. Note that this interpreter requires that <code>Embed IO</code> be present in our effect list, meaning that our monad must be able to handle arbitrary <code>IO</code> actions. That‚Äôs fine, but now we‚Äôll have to handle that effect as well. Since our goal is to eventually peel this onion into the <code>IO</code> monad, we‚Äôll want some function that can convert some <code>Sem r a</code> into an <code>IO a</code>. That function would be <code>runFinal :: Monad m =&gt; Sem '[Final m] a -&gt; m a</code> which takes a <code>Sem</code> with a singleton effect row containing just <code>Final m</code> for some monad <code>m</code> and returns a plain <code>m a</code>. To get such a <code>Final m</code> we can just use the <code>embedToFinal :: (Member (Final m) r, Functor m) =&gt; Sem (Embed m ': r) a -&gt; Sem r a</code> interpreter, which peels off an <code>Embed m</code> effect and delegates its effects to the <code>Final m</code> effect in our effect row.</p>
<p>Putting it all together:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> runFinal</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span> embedToFinal <span class="op">@</span><span class="dt">IO</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span> traceToIO</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span> runReader (<span class="dt">Config</span> <span class="st">&quot;!&quot;</span> <span class="op">...</span>)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">$</span> handleMessage <span class="st">&quot;!polysemy&quot;</span></span></code></pre></div>
<p>This may seem a bit complicated, but it‚Äôs a method that lets us easily deal with all the effects we need, one at a time. The result is very clean. Note that we never deal with an explicit effect row, the type checker infers it for us based on the interpreters we choose.</p>
<h3 id="di-and-di-polysemy"><code>di</code> and <code>di-polysemy</code></h3>
<p><code>di</code> is a fully-featured structured logging library. <code>di-polysemy</code> provides <code>polysemy</code> style effects for <code>di</code>. This is what <code>calamity</code> uses for logging.</p>
<h3 id="lens"><code>lens</code></h3>
<p>For a full understanding of how lens works, there are better resources such as the excellent <a href="https://artyom.me/lens-over-tea-1">lens over tea</a>. This will just be a quick overview of the basic usage of lenses for those who aren‚Äôt familiar with them.</p>
<p>A lens can be thought of as a value that focuses on some part of a larger structure, such as a field in a record. For example, <code>lens</code> provides the <code>_1</code> lens which focuses on the first element of a tuple. We can use a lens to extract part of a value with the <code>view</code> function or its operator counterpart, <code>(^.)</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> view (<span class="ch">'a'</span>, <span class="dv">5</span>) _1</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="ch">'a'</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> (<span class="ch">'a'</span>, <span class="dv">5</span>) <span class="op">^.</span> _2</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="dv">5</span></span></code></pre></div>
<p>We can replace part of a structure with the <code>set</code> function or its operator counterpart, <code>(.~)</code>. We can use the flipped application operator <code>(&amp;) = flip ($)</code> alongside this operator.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> set _1 <span class="st">&quot;hello&quot;</span> (<span class="ch">'a'</span>, <span class="dv">5</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>(<span class="st">&quot;hello&quot;</span>, <span class="dv">5</span>)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> (<span class="ch">'a'</span>, <span class="dv">5</span>) <span class="op">&amp;</span> _2 <span class="op">.~</span> <span class="dt">False</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>(<span class="ch">'a'</span>, <span class="dt">False</span>)</span></code></pre></div>
<p>And finally, we have <code>over</code> and its operator <code>%~</code> which work much the same way as <code>set</code>, but takes a function to modify the structure with rather than a set value.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> over _1 <span class="fu">succ</span> (<span class="ch">'a'</span>, <span class="dv">5</span>)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>(<span class="ch">'b'</span>, <span class="dv">5</span>)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> (<span class="ch">'a'</span>, <span class="dv">5</span>) <span class="op">&amp;</span> _2 <span class="op">%~</span> <span class="fu">show</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>(<span class="ch">'a'</span>, <span class="st">&quot;5&quot;</span>)</span></code></pre></div>
<p>Notably, we can compose lenses with the <code>(.)</code> operator from the <code>Prelude</code> to focus on parts of nested structures.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> (<span class="dt">True</span>, (<span class="ch">'a'</span>, <span class="dv">5</span>)) <span class="op">^.</span> _2 <span class="op">.</span> _1</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="ch">'a'</span></span></code></pre></div>
<h3 id="generic-lens"><code>generic-lens</code></h3>
<p>The goal of using <code>lens</code> here is to be able to access the fields of the various record types that <code>calamity</code> exposes to us. We could use record accessors and update notation, but many of these records contain fields with the same name, so using them directly will lead to ambiguity errors. <code>generic-lens</code> solves this issue for us by allowing us to create lenses on the fly using the <code>OverloadedLabels</code> extension. For example, the <code>Member</code> type has a field called <code>guildID</code>. If we want to access this field from some member <code>mem</code>, we can simply write <code>mem ^. #guildID</code>.</p>
<p>Note that to use the field names as lenses the type must have an instance of the <code>Generic</code> typeclass. This can be done with the <code>DeriveGeneric</code> extension, which, unsurprisingly, allows the user to write <code>deriving Generic</code>. All, or at least most, of the record types defined in <code>calamity</code> have a <code>Generic</code> instance.</p>
<h2 id="creating-the-skeleton">Creating the Skeleton</h2>
<p>Let‚Äôs begin by building the skeleton for our project. Initialize a fresh cabal project by running <code>cabal init</code> in an empty directory. We‚Äôll start by putting the adding the following dependencies in our <code>bot.cabal</code> file under <code>build-depends</code>.</p>
<pre class="plaintext"><code>  build-depends:
    , base             &gt;=4.14.1.0 &amp;&amp; &lt;5
    , calamity         &gt;=0.1.30   &amp;&amp; &lt;0.1.31
    , data-default     ^&gt;=0.7.1.1
    , data-flags       ^&gt;=0.0.3.4
    , di               ^&gt;=1.3
    , di-polysemy      ^&gt;=0.2.0.0
    , generic-lens     ^&gt;=2.1.0.0
    , lens             ^&gt;=5.0.1
    , polysemy         ^&gt;=1.5.0.0
    , polysemy-plugin  ^&gt;=0.3.0.0
    , text             ^&gt;=1.2.4.1
    , text-show        ^&gt;=3.9</code></pre>
<p><code>polysemy-plugin</code> is a GHC plugin for <code>polysemy</code> which improves type inference inside the <code>Sem r</code> monad. We have to enable it by adding <code>-fplugin=Polysemy.Plugin</code> to our GHC options.</p>
<pre class="plaintext"><code>  ghc-options:      -fplugin=Polysemy.Plugin</code></pre>
<p>Let‚Äôs also start with a couple of language extensions.<code>TypeApplications</code> which lets us instantiate polymorphic values with concrete types, <code>OverloadedStrings</code> to be able to write <code>Text</code> literals, and <code>OverloadedLabels</code> for use with <code>generic-lens</code>. We‚Äôll also need <code>DataKinds</code> later.</p>
<pre class="plaintext"><code>  default-extensions:
    DataKinds
    OverloadedLabels
    OverloadedStrings
    TypeApplications</code></pre>
<p>We‚Äôll build all these dependencies with <code>cabal build --only-dependencies</code>.</p>
<p>Let‚Äôs write the skeleton for the <code>main</code> function.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Calamity</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Calamity.Cache.InMemory</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Calamity.Commands</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Calamity.Commands.Context</span> (useFullContext)</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Calamity.Metrics.Noop</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Control.Lens</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Control.Monad</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Data.Default</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Data.Generics.Labels</span>      ()</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Data.Maybe</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Data.Text.Lazy</span>            (<span class="dt">Text</span>)</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.Lazy</span>            <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Di</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">DiPolysemy</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Polysemy</span>                  <span class="kw">as</span> <span class="dt">P</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> Di.new <span class="op">$</span> \di <span class="ot">-&gt;</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>  void</span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span> P.runFinal</span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span> P.embedToFinal <span class="op">@</span><span class="dt">IO</span></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span> runDiToIO di</span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span> runCacheInMemory</span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span> runMetricsNoop</span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span> useFullContext</span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span> useConstantPrefix <span class="st">&quot;!&quot;</span></span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span> runBotIO (<span class="dt">BotToken</span> <span class="st">&quot;&lt;token&gt;&quot;</span>) defaultIntents</span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a>  <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a>    info <span class="op">@</span><span class="dt">Text</span> <span class="st">&quot;Bot starting up!&quot;</span></span></code></pre></div>
<p>Let‚Äôs break this down bit by bit.</p>
<p><code>Di.new</code> has the type</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">new ::</span> (<span class="dt">Di</span> <span class="dt">Level</span> <span class="dt">Path</span> <span class="dt">Message</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span></code></pre></div>
<p>It‚Äôs a bit more polymorphic than that, but we‚Äôre just using it in plain <code>IO</code>. It essentially provides us a <code>Di Level Path Message</code> using a continuation. That value can be thought of as a sort of handle to the logger.</p>
<p>Now for the effect interpreters.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- snip --</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span> runBotIO (<span class="dt">BotToken</span> <span class="st">&quot;&lt;token&gt;&quot;</span>) defaultIntents</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- snip --</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- `runBotIO` has the type:</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>runBotIO</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> <span class="kw">forall</span> r a<span class="op">.</span> ( <span class="dt">Members</span> '[<span class="dt">Embed</span> <span class="dt">IO</span>, <span class="dt">Final</span> <span class="dt">IO</span>, <span class="dt">CacheEff</span>, <span class="dt">MetricEff</span>, <span class="dt">LogEff</span>] r</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>                 , <span class="dt">Typeable</span> (<span class="dt">SetupEff</span> r))</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> <span class="dt">Token</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">Intents</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">Sem</span> (<span class="dt">SetupEff</span> r) a</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">Sem</span> r (<span class="dt">Maybe</span> <span class="dt">StartupError</span>)</span></code></pre></div>
<p><code>runBotIO</code> is the main effect interpreter. It may look daunting, but let‚Äôs break it down piece by piece. Firstly, we‚Äôll note it takes a <code>Token</code> and an <code>Intents</code> as inputs. A <code>Token</code>, as you can see in our skeleton, can be constructed using the <code>BotToken</code> constructor. An <code>Intents</code> is just a <code>Word32</code> representing a bunch of binary flags. You can combine these intents and manipulate them with methods from the <code>Flags</code> typeclass from the <code>data-flags</code> package.</p>
<p><code>SetupEff r</code> is a type alias for <code>Reader Client ': (AtomicState EventHandlers ': (Async ': r))</code>. What that means, in particular, is not relevant to us right now, just understand that it‚Äôs <code>r</code> with extra effects tacked on.</p>
<p><code>Members '[Embed IO, Final IO, CacheEff, MetricEff, LogEff] r</code> is equivalent to <code>(Member (Embed IO) r, Member (Final IO) r, ...)</code>, it‚Äôs just a more convenient way of listing them all.</p>
<p>So, what this whole function does is strip off some of the main effects but requires us to interpret a few other effects afterward. It‚Äôs the main interpreter, in a nutshell.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- snip --</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span> useConstantPrefix <span class="st">&quot;!&quot;</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- snip --</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- `useConstantPrefix` has the type:</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="ot">useConstantPrefix ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Sem</span> (<span class="dt">ParsePrefix</span> '<span class="op">:</span> r) a <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</span></code></pre></div>
<p>Having this interpreter will strip off the <code>ParsePrefix</code> effect, which will be required when we want to register commands later.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- snip --</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span> useFullContext</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- snip --</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- `useFullContext` has the type:</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="ot">useFullContext ::</span> <span class="dt">Member</span> <span class="dt">CacheEff</span> r <span class="ot">=&gt;</span> <span class="dt">Sem</span> (<span class="dt">ConstructContext</span> <span class="dt">Message</span> <span class="dt">FullContext</span> <span class="dt">IO</span> () '<span class="op">:</span> r) a <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</span></code></pre></div>
<p><code>useConstantPrefix</code> handles the <code>ConstructContext</code> effect, which determines what information we receive when a command is invoked.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- snip --</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span> runMetricsNoop</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- snip --</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- `runMetricsNoop` has the type:</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="ot">runMetricsNoop ::</span> <span class="dt">Sem</span> (<span class="dt">MetricEff</span> '<span class="op">:</span> r) a <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</span></code></pre></div>
<p><code>runMetricsNoop</code> will strip off the <code>MetricEff</code> effect by ignoring any metrics that were collected. <code>calamity</code> doesn‚Äôt provide any other interpreter for the <code>MetricEff</code> effect, but if we wanted to we could write our own. That‚Äôs outside the scope of this post, however.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- snip --</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span> runCacheInMemory</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- snip --</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- `runCacheInMemory` has the type:</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="ot">runCacheInMemory ::</span> <span class="dt">Member</span> (<span class="dt">Embed</span> <span class="dt">IO</span>) r <span class="ot">=&gt;</span> <span class="dt">Sem</span> (<span class="dt">CacheEff</span> '<span class="op">:</span> r) a <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</span></code></pre></div>
<p><code>runCacheInMemory</code> strips the <code>CacheEff</code> for us by storing the cache in memory. If we wanted to we could write an effect interpreter that stores the cache in a file or database.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- snip --</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span> runDiToIO di</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- snip --</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- `runDiToIO` has the type:</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>runDiToIO</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> <span class="kw">forall</span> r level msg a<span class="op">.</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>     <span class="dt">Member</span> (<span class="dt">Embed</span> <span class="dt">IO</span>) r</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> <span class="dt">Di</span> level <span class="dt">Path</span> msg</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">Sem</span> (<span class="dt">Di</span> level <span class="dt">Path</span> msg '<span class="op">:</span> r) a</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</span></code></pre></div>
<p><code>runDiToIO</code> will interpret our <code>di</code> logging effect. Note that the <code>LogEff</code> effect mentioned earlier is just a type alias for <code>Di Level Path Message</code>, so this is just an interpreter for the <code>LogEff</code> effect.</p>
<h2 id="our-first-event-handler">Our First Event Handler</h2>
<p>Let‚Äôs create an event handler that will do something wholesome, like react with üòÑ on any message containing the string ‚ÄúHaskell‚Äù.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- snip --</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="op">$</span> <span class="kw">do</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    info <span class="op">@</span><span class="dt">Text</span> <span class="st">&quot;Bot starting up!&quot;</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    react <span class="op">@</span><span class="dt">'MessageCreateEvt</span> <span class="op">$</span> \msg <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>      when (<span class="st">&quot;Haskell&quot;</span> <span class="ot">`T.isInfixOf`</span> (msg <span class="op">^.</span> <span class="op">#</span>content)) <span class="op">$</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>        void <span class="op">.</span> invoke <span class="op">$</span> <span class="dt">CreateReaction</span> msg msg (<span class="dt">UnicodeEmoji</span> <span class="st">&quot;üòÑ&quot;</span>)</span></code></pre></div>
<p><code>react</code> is a function that registers an event handler.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>react</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> <span class="kw">forall</span> (<span class="ot">s ::</span> <span class="dt">EventType</span>) r<span class="op">.</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">BotC</span> r, <span class="dt">ReactConstraints</span> s)</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> (<span class="dt">EHType</span> s <span class="ot">-&gt;</span> <span class="dt">Sem</span> r ())</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">Sem</span> r (<span class="dt">Sem</span> r ())</span></code></pre></div>
<p>The type of event we want to handle has to be passed in as a <em>type argument</em> using the <code>TypeApplications</code> extension, which allows us to instantiate type variables to a specific concrete type. <code>calamity</code> provides the <code>EventType</code> datatype which is a simple enumeration, one of the values being <code>MessageCreateEvt</code>. <code>react</code> expects a type variable with the <em>kind</em> <code>EventType</code>, meaning <code>EventType</code> is used as a data-kind. All this means is that the type <code>EventType</code> is promoted from the type level to the kind level. Its values, such as <code>MessageCreateEvt</code>, are promoted from the term level to the type level. Just as the type <code>Int</code> has kind <code>Type</code>, the type <code>'MessageCreateEvt</code> has the kind <code>EventType</code>. Notice the tick mark on <code>'MessageCreateEvt</code>. This is to differentiate the value <code>MessageCreateEvt</code> from the type. Usually, GHC can infer this without us explicitly specifying it, and indeed here it‚Äôs not required, but we‚Äôll leave it in just to be explicit.</p>
<p>Also, note that the effect row that <code>react</code> uses has a <code>BotC</code> constraint which is just an alias for a few other constraints. We won‚Äôt go into the details here, but just know that the <code>runBotIO</code> interpreter handles these constraints for us.</p>
<p><code>react</code> also expects a function as an argument, the handler body. The type of the input to the body depends on the <code>EventType</code> we specified; different types of events have different data associated with them. This is determined by the <code>EHType</code> type family. For those unfamiliar, a type family is essentially a function that operates on <em>types</em> rather than terms. In the case of <code>EHType</code>, it takes a type with kind <code>EventType</code> (remember, <code>DataKinds</code> promotes <code>EventType</code> to the kind level) and gives us a type. So in our case, <code>EHType 'MessageCreateEvt = Messaage</code>. That means our event handler‚Äôs body should have the type <code>Message -&gt; Sem r ()</code>.</p>
<p>So for the actual body, we want to take the message and perform an action conditional on the message‚Äôs content. We use the <code>when</code> function from <code>Control.Monad</code>, which conditionally performs a monadic/applicative action.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="ot">when ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> f () <span class="ot">-&gt;</span> f ()</span></code></pre></div>
<p>To access the message‚Äôs content we use <code>generic-lens</code> to <code>view</code> the <code>content</code> field of the message (remember that <code>(^.)</code> is just the infix counterpart to <code>view</code>).</p>
<p>To create the action, we‚Äôll need to create a ‚Äúcreate reaction‚Äù request, specifically a <code>ChannelRequest</code>.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="dt">CreateReaction</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> (<span class="dt">HasID</span> <span class="dt">Channel</span> c, <span class="dt">HasID</span> <span class="dt">Message</span> m)</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> c</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> m</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">RawEmoji</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">ChannelRequest</span> ()</span></code></pre></div>
<p><code>CreateReaction</code> is polymorphic in its first two arguments. Rather than requiring a concrete <code>Snowflake</code> for the channel and message to react to, which, it only requires that it‚Äôs possible to extract a <code>Snowflake</code> from the inputs. It does this via a typeclass, <code>HasID</code>, which has two type parameters- the type of the <code>Snowflake</code> we wish to extract and the type of the thing to extract from. It has a single method, <code>HasID b a =&gt; getID :: a -&gt; Snowflake b</code>. If we look at the instances for <code>HasID</code> we see that there are indeed instances <code>HasID Channel Message</code> and <code>HasID Message Message</code>. To illustrate the convenience that this technique gives us, this is what our handler would look like if <code>CreateReaction</code> required concrete <code>Snowflake</code>s.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- snip --</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>void <span class="op">.</span> invoke <span class="op">$</span> <span class="dt">CreateReaction</span> (msg <span class="op">^.</span> <span class="op">#</span>channelID) (msg <span class="op">^.</span> <span class="op">#</span>id) (<span class="dt">UnicodeEmoji</span> <span class="st">&quot;üòÑ&quot;</span>)</span></code></pre></div>
<p>Okay, so now that we have our <code>ChannelRequest</code> we can use the <code>invoke</code> function to run it.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>invoke</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> (<span class="dt">BotC</span> r, <span class="dt">Request</span> a, <span class="dt">FromJSON</span> (<span class="dt">Result</span> a))</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> a</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">Sem</span> r (<span class="dt">Either</span> <span class="dt">RestError</span> (<span class="dt">Result</span> a))</span></code></pre></div>
<p>Here, <code>Request</code> is a typeclass for which every <code>ChannelRequest a</code> has an instance, and <code>Result</code> is a type family which extracts the type <code>a</code> from a <code>ChannelRequest a</code>.</p>
<p>In our case, since we don‚Äôt need the result of the request, we can discard it using the <code>void</code> function from <code>Control.Monad</code>.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ot">void ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> f ()</span></code></pre></div>
<p>One last thing to note about <code>react</code> is that it returns an action that you can use to unregister it, hence the output being <code>Sem r (Sem r ())</code>.</p>
<p>That‚Äôs it! That‚Äôs our event handler. You can try it out yourself by putting your bot token in the <code>runBotIO</code> interpreter and running the project.</p>
<h2 id="adding-a-command">Adding a command</h2>
<p>Let‚Äôs add a command to enable (or disable) slow mode at a given duration, optionally specifying a channel, defaulting to the channel the command was invoked in.</p>
<p>Luckily for us, <code>calamity</code> provides a handy DSL for creating commands.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- snip --</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>        void <span class="op">.</span> invoke <span class="op">$</span> <span class="dt">CreateReaction</span> msg msg (<span class="dt">UnicodeEmoji</span> <span class="st">&quot;üòÑ&quot;</span>)</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    addCommands <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>      helpCommand</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>      command <span class="op">@</span>'[<span class="dt">Int</span>, <span class="dt">Maybe</span> <span class="dt">GuildChannel</span>] <span class="st">&quot;slowmode&quot;</span> <span class="op">$</span> \ctx seconds mchan <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> cid <span class="ot">=</span> <span class="fu">maybe</span> (ctx <span class="op">^.</span> <span class="op">#</span>channel <span class="op">.</span> to getID) getID<span class="ot"> mchan ::</span> <span class="dt">Snowflake</span> <span class="dt">Channel</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>        void <span class="op">.</span> invoke <span class="op">$</span> <span class="dt">ModifyChannel</span> cid <span class="op">$</span> def</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>          <span class="op">&amp;</span> <span class="op">#</span>rateLimitPerUser <span class="op">?~</span> seconds</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>        void <span class="op">.</span> invoke <span class="op">$</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>          <span class="dt">CreateReaction</span> (ctx <span class="op">^.</span> <span class="op">#</span>channel) (ctx <span class="op">^.</span> <span class="op">#</span>message) (<span class="dt">UnicodeEmoji</span> <span class="st">&quot;‚úÖ&quot;</span>)</span></code></pre></div>
<p>Registering commands is done with the <code>addCommands</code> function.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>addCommands</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> (<span class="dt">BotC</span> r, <span class="dt">Member</span> <span class="dt">ParsePrefix</span> r)</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> <span class="dt">Sem</span> (<span class="dt">DSLState</span> r) a</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">Sem</span> r (<span class="dt">Sem</span> r (), <span class="dt">CommandHandler</span>, a)</span></code></pre></div>
<p>It constructs the commands and registers the proper event handlers to handle them. It requires the <code>ParsePrefix</code> effect to be present in the effect row. It also allows extra effects in the input‚Äôs effect row which are used to track the state of the command DSL, using the type alias <code>DSLState</code>. It yields an action to unregister the event handlers, and an object representing the commands that were registered.</p>
<p><code>helpCommand</code> will add a default help command in the DSL.</p>
<p>To create a command, we use the <code>command</code> function</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>command</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> <span class="kw">forall</span> ps r<span class="op">.</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">Member</span> (<span class="dt">Final</span> <span class="dt">IO</span>) r, <span class="dt">TypedCommandC</span> ps r)</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> <span class="dt">Text</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> (<span class="dt">Context</span> <span class="ot">-&gt;</span> <span class="dt">CommandForParsers</span> ps r)</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">Sem</span> (<span class="dt">DSLState</span> r) <span class="dt">Command</span></span></code></pre></div>
<p><code>command</code> takes a command name and a command body and adds a command in the DSL. It also takes a type-level list of command arguments, which it uses to parse the inputs and compute the type of the command body.</p>
<p>In our case, we pass the type-level list <code>'[Int, Maybe GuildChannel]</code> (using <code>TypeApplications</code>) which means our command requires an <code>Int</code> and optionally a <code>GuildChannel</code>.</p>
<p>The body of the command will take a <code>Context</code> and any type parameters we pass in will also be the types of arguments to the body (computed by the <code>CommandForParsers</code> type family).</p>
<p>We use the <code>maybe</code> function to get a default channel id- either the id of the channel provided or the id of the channel the message was invoked in, which is extracted from the <code>Context</code>. We need the id specifically even though the <code>ModifyChannel</code> request only requires something which has a <code>HasID Channel</code> instance, since <code>maybe</code> requires the output types to match up.</p>
<p>We invoke the <code>ModifyChannel</code> request.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="dt">ModifyChannel</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> <span class="dt">HasID</span> <span class="dt">Channel</span> c</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> c</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">ChannelUpdate</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">ChannelRequest</span> <span class="dt">Channel</span></span></code></pre></div>
<p>It requires a <code>ChannelUpdate</code> as input.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ChannelUpdate</span> <span class="ot">=</span> <span class="dt">ChannelUpdate</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> name ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> position ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> topic ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> nsfw ::</span> <span class="dt">Maybe</span> <span class="dt">Bool</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> rateLimitPerUser ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> bitrate ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> userLimit ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> permissionOverwrites ::</span> <span class="dt">Maybe</span> [<span class="dt">Overwrite</span>]</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> parentID ::</span> <span class="dt">Maybe</span> (<span class="dt">Snowflake</span> <span class="dt">Channel</span>)</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>In our case, we just need the <code>rateLimitPerUser</code> field. Luckily, <code>ChannelUpdate</code> implements the <code>Default</code> typeclass, and so it provides a default value <code>def</code> in which all the fields are set to <code>Nothing</code>. We can then use <code>lens</code> to update just the field we need. We can use the <code>(?~)</code> operator, which is a convenience function that <code>set</code>s a field to <code>Just</code> the value on the right-hand side.</p>
<p>We also react to the command invocation, just like we did in our event handler, this time using the <code>Context</code> instead of a <code>Message</code>.</p>
<p>The parser for the command is quite intelligent, so when we come to run the command, we can pass in either a link to the channel (ala <code>#channel-name</code>) or the id of the channel.</p>
<h2 id="creating-messages-with-ease-using-the-tell-function">Creating Messages with Ease Using the <code>tell</code> Function</h2>
<p><code>calamity</code> has a typeclass called <code>Tellable</code>, which has a method <code>getChannel</code>.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>getChannel </span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> (<span class="dt">BotC</span> r, <span class="dt">Member</span> (<span class="dt">Error</span> <span class="dt">RestError</span>) r) </span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> a </span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">Sem</span> r (<span class="dt">Snowflake</span> <span class="dt">Channel</span>)</span></code></pre></div>
<p>Any type which has an instance of <code>Tellable</code> can be sent a message with the <code>tell</code> function.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>tell </span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> <span class="kw">forall</span> msg r t<span class="op">.</span> </span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">BotC</span> r, <span class="dt">ToMessage</span> msg, <span class="dt">Tellable</span> t) </span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> t </span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> msg </span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">Sem</span> r (<span class="dt">Either</span> <span class="dt">RestError</span> <span class="dt">Message</span>)</span></code></pre></div>
<p>It also requires the item being sent to have a <code>ToMessage</code> instance. Many types have this instance, among them the various string types, files, embeds, and mentions.</p>
<p>Let‚Äôs create an event handler that responds to any message edit with ‚ÄúHey! I saw that!‚Äù.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- snip --</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    react <span class="op">@</span><span class="dt">'MessageUpdateEvt</span> <span class="op">$</span> \(_oldMsg, newMsg) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>      void <span class="op">.</span> tell <span class="op">@</span><span class="dt">Text</span> newMsg <span class="op">$</span> <span class="st">&quot;Hey! I saw that!&quot;</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- snip --</span></span></code></pre></div>
<h2 id="supercharge-your-snowflakes-with-upgrade">Supercharge your <code>Snowflake</code>s with <code>upgrade</code></h2>
<p>It can be a hassle to get a value if you only have access to its id. <code>calamity</code> provides us with the <code>Upgradable</code> typeclass, which provides the <code>upgrade</code> method.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Upgradeable</span> a ids <span class="op">|</span> a <span class="ot">-&gt;</span> ids, ids <span class="ot">-&gt;</span> a <span class="kw">where</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  upgrade ::</span> <span class="dt">BotC</span> r <span class="ot">=&gt;</span> ids <span class="ot">-&gt;</span> <span class="dt">P.Sem</span> r (<span class="dt">Maybe</span> a)</span></code></pre></div>
<p><code>upgrade</code> will take your id(s) and search the cache for the corresponding value, making a request if it‚Äôs not in the cache. There are several useful instances defined, all of which take one or a pair of <code>Snowflake</code>s and provide a complete value.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a> <span class="dt">Upgradeable</span> <span class="dt">GuildChannel</span> (<span class="dt">Snowflake</span> <span class="dt">GuildChannel</span>) </span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a> <span class="dt">Upgradeable</span> <span class="dt">Member</span> (<span class="dt">Snowflake</span> <span class="dt">Guild</span>, <span class="dt">Snowflake</span> <span class="dt">Member</span>)</span></code></pre></div>
<h2 id="utilities">Utilities</h2>
<p><code>Calamity.Utils</code> provides many useful functions: permissions calculations, message formatting, and colors for custom embeds. It‚Äôs worthwhile to check it out.</p>
<h2 id="in-summary">In Summary</h2>
<p>There are many things we didn‚Äôt get to cover in this post. We only scratched the surface of the commands DSL, we didn‚Äôt cover metrics collection, presences, nor the countless datatypes that are defined to model the Discord API. We also didn‚Äôt cover most of the effects available in the <code>polysemy</code> library, which could come in handy for storing configuration data, state, etc. But that‚Äôs where the documentation comes in. If you‚Äôre new to developing real-world Haskell programs, learning how to read the haddocks is invaluable. (A tip: Don‚Äôt forget to read the instances!)</p>
<p>If there‚Äôs further interest in this I may be inclined to write another post where I write a more fully-featured bot and step through the process, involving other libraries like <code>aeson</code> and database libraries, and defining our own polysemy effects and effect interpreters.</p>
<p>The full source code for the bot is available <a href="https://github.com/MorrowM/calamity-tutorial">here</a>.</p>
    </section>
</article>
        </main>
    </div>
    <footer>
        <div class="copyright-notice">
            ¬© 2021 MorrowM
        </div>
        Site proudly generated by
        <a class="no-link-color" href="http://jaspervdj.be/hakyll">Hakyll</a>
    </footer>
</body>

</html>